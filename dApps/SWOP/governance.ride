{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let adminPubKey1 = base58'DXDY2itiEcYBtGkVLnkpHtDFyWQUkoLJz79uJ7ECbMrA'
let adminPubKey2 = base58'E6Wa1SGoktYcjHjsKrvjMiqJY3SWmGKcD8Q5L8kxSPS7'
let adminPubKey3 = base58'AZmWJtuy4GeVrMmJH4hfFBRApe1StvhJSk4jcbT6bArQ'
let adminPubKeyStartStop = base58'EtVkT6ed8GtbUiVVEqdmEqsp2J4qbb3rre2HFgxeVYdg'
let adminPubKeyWallet = base58'GTY8yEJ2S4heRompxyvbJoBN1Td5BM5Pp4JgVbj9tmCw'

# SWOP voting: keys and function | start
# let keyUserTotalSWOP = "_total_SWOP"
let keyActive = "active"
let keyCause = "shutdown_cause"
let keyLastInterest = "last_interest"
let keyUserLastInterest = "_last_interest"
let keyUserSWOPLocked = "_SWOP_amount"
let keyUserGetBackHeight = "_getBackHeight"
let keyTotalSWOPLocked = "total_SWOP_amount"
let kUserTotalVoteSWOP = "_user_total_SWOP_vote"
let keyUserVoteOptionAmount = "_SWOP_option_amount" 
let keyTotalVoteOptionAmount = "total_SWOP_option_amount"
let keyUserSWOPClaimedAmount = "_SWOP_claimed_amount"
let keyUserSWOPLastClaimedAmount = "_SWOP_last_claimed_amount"
let keyVoteName = "vote_name"
let keyOptionName = "_option_name"
let keyVotingStartHeight = "_startHeight"
let keyVoteDuration = "_vote_duration"
let keyRewardPoolFractionCurrent = "_current_pool_fraction_reward"
let keyRewardPoolFractionPrevious = "_previous_pool_fraction_reward"
let keyTotalRewardPerBlockCurrent = "total_reward_per_block_current"
let keyTotalRewardPerBlockPrevious = "total_reward_per_block_previous"
let keyRewardUpdateHeight = "reward_update_height"

let isActive = this.getBoolean(keyActive).valueOrElse(true)

let farmingSWOPAddress = Address(base58'3P73HDkPqG15nLXevjCbmXtazHYTZbpPoPw')
let votingLiteContract = Address(base58'3PQZWxShKGRgBN1qoJw6B4s9YWS9FneZTPg')

let keySWOPid = "SWOP_id"
let SWOP = farmingSWOPAddress.getStringValue(keySWOPid).fromBase58String()
let scaleValue = 100000000 # 10^8
let totalVoteShare = 10000000000

let kStartHeight = "start_height"
let kBasePeriod = "base_period"
let kPeriodLength = "period_length"
let kUserTotalStruc = "_user_total_struc"
let basePeriod = votingLiteContract.getInteger(kBasePeriod).valueOrErrorMessage("Empty kBasePeriod at voting contract") 
let startHeight = votingLiteContract.getInteger(kStartHeight) .valueOrErrorMessage("Empty kStartHeight at voting contract")
let periodLength =  votingLiteContract.getInteger(kPeriodLength).valueOrErrorMessage("Empty kPeriodLength at voting contract")  
let currVotingPeriod = basePeriod + (height-startHeight)/periodLength

func suspend(cause: String) = [
    BooleanEntry(keyActive, false),
    StringEntry(keyCause, cause)
]

func throwNotEnoughSWOP() = throw("Not enough SWOP: userSWOPLocked - userTotalVoteAmount < voteSWOPAmount")

func getLastInterestInfo() = {
    let lastInterest = this.getInteger(keyLastInterest)
                           .valueOrElse(0)
    lastInterest
}

func getUserSWOPLocked(user:Address) =  this.getInteger(user.toString() + keyUserSWOPLocked)
                                                .valueOrElse(0)
func getUserSWOPClaimedAmount(user:Address) =  this.getInteger(user.toString() + keyUserSWOPClaimedAmount)
                                                .valueOrElse(0)

func getUserInterestInfo(user:Address, lastInterest: Int) = {
    let userSWOPAmount = getUserSWOPLocked(user)
    let userLastInterest = this.getInteger(user.toString() + keyUserLastInterest)
    let userLastInterestValue = match userLastInterest {
        case userLastInterest: Int => userLastInterest
        case _ => lastInterest
    }
    (userLastInterestValue,userSWOPAmount)
}

func getTotalSWOPLocked() = this.getInteger(keyTotalSWOPLocked)
                                                .valueOrElse(0)

func getUserUnvoteAmount(user:Address) = {
    let (userTotalVoteSWOP,userUnvoted,userUnvotedPeriod) = if isDefined(this.getString(user.toString() + kUserTotalStruc))
        then 
            let data = votingLiteContract.getString(user.toString() + kUserTotalStruc).valueOrErrorMessage("Empty kUserTotalStruc").split("_")
            (data[0].parseIntValue(),data[1].parseIntValue(),data[2].parseIntValue())
        else 
            let uPoolTotalSWOP = votingLiteContract.getInteger(toString(user) + kUserTotalVoteSWOP).valueOrElse(0)
            (uPoolTotalSWOP,0,currVotingPeriod)

    if userUnvotedPeriod == currVotingPeriod then 
        userUnvoted
    else 0
}

func getUserVoteOptionAmount(user:Address) = this.getInteger(user.toString() + keyUserVoteOptionAmount)
                                                .valueOrElse(0)

func getVotingStartHeight(voteName:String) =  this.getInteger(voteName + keyVotingStartHeight)
                                                .valueOrElse(0)

func getVoteOptionAmount(user:Address, voteName:String, option:String) =  {
    let userVoteOptionAmount = this.getInteger(voteName + option + user.toString() + keyUserVoteOptionAmount)
    let uvoa = match userVoteOptionAmount {
        case uvoa: Int => uvoa
        case uvoa: Unit => 0
        }
    uvoa.valueOrErrorMessage("No data on the key: " + voteName + option + user.toString() + keyUserVoteOptionAmount)
}

func getVoteDuration(voteName:String) =  this.getInteger(voteName + keyVoteDuration)
                                                .valueOrErrorMessage("No data on the key: " + voteName + keyVoteDuration)

func getTotalVoteOptionAmount(voteName: String, option: String) = {
    let totalVoteOptionAmount = this.getInteger(voteName + option +  keyTotalVoteOptionAmount)
    let tvoa = match totalVoteOptionAmount {
        case tvoa: Int => tvoa
        case tvoa: Unit => 0
        }
    tvoa
}

func getUserGetBackAmount(voteName:String,option:String,user:Address,getBackSWOPHeight:Int) = {
    let key = voteName + "_" + option + "_" + user.toString() + "_" + getBackSWOPHeight.toString()
    this.getInteger(key)
        .valueOrErrorMessage("No data on the key: " + key)
}
# SWOP voting: keys and function | end
func claimCalc(caller:Address) = {
    let lastInterest = getLastInterestInfo()
    let (userLastInterest,userSWOPLocked) = getUserInterestInfo(caller,lastInterest)
    let claimAmount = fraction(userSWOPLocked,lastInterest-userLastInterest,scaleValue)
    let userNewInterest = lastInterest
    (userNewInterest,claimAmount)
}

@Callable(i)
func airDrop() = if !isActive then throw("DApp is inactive at this moment") else {
    let (pmtAmount, pmtAssetId) = (i.payments[0].amount, i.payments[0].assetId)
    if (pmtAssetId != SWOP)
        then throw("Incorrect pmtAssetId")
    else {
        let totalSWOPLocked = getTotalSWOPLocked()
        let lastInterest = getLastInterestInfo()
        let interestNew = (lastInterest + fraction(pmtAmount, scaleValue, totalSWOPLocked))
        [IntegerEntry(keyLastInterest, interestNew)]
    }
}

@Callable(i)
func lockSWOP() = if !isActive then throw("DApp is inactive at this moment") else {
    let (pmtAmount, pmtAssetId) = (i.payments[0].amount, i.payments[0].assetId)
    if pmtAssetId != SWOP then throw("Incorrect pmtAssetId") else
    let lastInterest = getLastInterestInfo()
    let (userLastInterest,userSWOPLocked) = getUserInterestInfo(i.caller,lastInterest)
    let claimAmount = fraction(userSWOPLocked,lastInterest-userLastInterest,scaleValue)
    let userSWOPLockedNew = userSWOPLocked + pmtAmount + claimAmount
    let userNewInterest = lastInterest
    let totalSWOPLocked = getTotalSWOPLocked()
    let totalSWOPLockedNew = totalSWOPLocked + pmtAmount + claimAmount
    let userClaimedAmount = getUserSWOPClaimedAmount(i.caller)
    let userClaimedAmountNew = userClaimedAmount + claimAmount
    [
        IntegerEntry(i.caller.toString() + keyUserLastInterest, userNewInterest),
        IntegerEntry(i.caller.toString() + keyUserSWOPLocked, userSWOPLockedNew),
        IntegerEntry(keyTotalSWOPLocked, totalSWOPLockedNew),
        IntegerEntry(i.caller.toString() + keyUserSWOPClaimedAmount, userClaimedAmountNew),
        IntegerEntry(i.caller.toString() + keyUserSWOPLastClaimedAmount, claimAmount)
    ]
}

@Callable(i)
func withdrawSWOP(withdrawAmount: Int) = if !isActive then throw("DApp is inactive at this moment") else {
    let totalSWOPLocked = getTotalSWOPLocked()
    let userSWOPLocked = getUserSWOPLocked(i.caller)
    let (userNewInterest,claimAmount) = claimCalc(i.caller)
    let userUnvoteAmount = getUserUnvoteAmount(i.caller)
    let availableFund = userSWOPLocked - userUnvoteAmount
    if withdrawAmount > availableFund then throw("withdrawAmount > availableFund") else
    let totalSWOPLockedNew = totalSWOPLocked + claimAmount - withdrawAmount
    let userSWOPamountNew = userSWOPLocked + claimAmount - withdrawAmount
    let userClaimedAmount = getUserSWOPClaimedAmount(i.caller)
    let userClaimedAmountNew = userClaimedAmount + claimAmount
    [
        IntegerEntry(i.caller.toString() + keyUserLastInterest, userNewInterest),
        IntegerEntry(i.caller.toString() + keyUserSWOPLocked, userSWOPamountNew),
        IntegerEntry(keyTotalSWOPLocked, totalSWOPLockedNew),
        ScriptTransfer(i.caller, withdrawAmount, SWOP),
        IntegerEntry(i.caller.toString() + keyUserSWOPClaimedAmount, userClaimedAmountNew),
        IntegerEntry(i.caller.toString() + keyUserSWOPLastClaimedAmount, claimAmount)
    ]
}

@Callable(i)
func claimAndWithdrawSWOP() = if !isActive then throw("DApp is inactive at this moment") else {
    let lastInterest = getLastInterestInfo()
    let (userNewInterest,claimAmount) = claimCalc(i.caller)
    let userClaimedAmount = getUserSWOPClaimedAmount(i.caller)
    let userClaimedAmountNew = userClaimedAmount + claimAmount
    if claimAmount == 0 then throw("You have 0 available SWOP") else
    [
        IntegerEntry(i.caller.toString() + keyUserLastInterest, userNewInterest),
        IntegerEntry(i.caller.toString() + keyUserSWOPClaimedAmount, userClaimedAmountNew),
        IntegerEntry(i.caller.toString() + keyUserSWOPLastClaimedAmount, claimAmount),
        ScriptTransfer(i.caller, claimAmount, SWOP)
    ]
}

@Callable(i)
func claimAndStakeSWOP() = if !isActive then throw("DApp is inactive at this moment") else {
    let totalSWOPLocked = getTotalSWOPLocked()
    let userSWOPLocked = getUserSWOPLocked(i.caller)
    let lastInterest = getLastInterestInfo()
    let (userNewInterest,claimAmount) = claimCalc(i.caller)
    let userSWOPLockedNew = userSWOPLocked + claimAmount 
    let totalSWOPLockedNew = totalSWOPLocked + claimAmount
    let userClaimedAmount = getUserSWOPClaimedAmount(i.caller)
    let userClaimedAmountNew = userClaimedAmount + claimAmount
    if claimAmount == 0 then throw("You have 0 available SWOP") else
    [
        IntegerEntry(i.caller.toString() + keyUserLastInterest, userNewInterest),
        IntegerEntry(keyTotalSWOPLocked, totalSWOPLockedNew),
        IntegerEntry(i.caller.toString() + keyUserSWOPLocked, userSWOPLockedNew ),
        IntegerEntry(i.caller.toString() + keyUserSWOPClaimedAmount, userClaimedAmountNew),
        IntegerEntry(i.caller.toString() + keyUserSWOPLastClaimedAmount, claimAmount)
    ]
}

@Callable(i)
func updateWeights(previousPools: List[String],previousRewards: List[Int],currentPools: List[String],currentRewards: List[Int],rewardUpdateHeight: Int) = if !isActive then throw("DApp is inactive at this moment") else {
     if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStartStop].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else
    
    func sum(a:Int, b:Int) = a + b

    func PreviousRewardEntry(accumulated: List[IntegerEntry], pool: String) = {
        let poolIndex = previousPools.indexOf(pool).value()
        let poolReward = previousRewards[poolIndex]
        IntegerEntry(pool+keyRewardPoolFractionPrevious,poolReward) :: accumulated
    }
    func CurrentRewardEntry(accumulated: List[IntegerEntry], pool: String) = {
        let poolIndex = currentPools.indexOf(pool).value()
        let poolReward = currentRewards[poolIndex]
        IntegerEntry(pool+keyRewardPoolFractionCurrent,poolReward) :: accumulated
    }
    let sumRewardPrevious = FOLD<20>(previousRewards, 0, sum)
    let sumRewardCurrent =  FOLD<20>(currentRewards, 0, sum)

    if rewardUpdateHeight < height then 
        throw("rewardUpdateHeight < height") else 
    if sumRewardPrevious != totalVoteShare || sumRewardCurrent != totalVoteShare then 
        throw("sumRewardPrevious != totalVoteShare or sumRewardCurrent != totalVoteShare")  else

    let previousRewardEntryNew = FOLD<20>(previousPools, [], PreviousRewardEntry)
    let currentRewardEntryNew = FOLD<20>(currentPools, [], CurrentRewardEntry)
    previousRewardEntryNew ++ currentRewardEntryNew ++ [IntegerEntry(keyRewardUpdateHeight,rewardUpdateHeight)]
}

@Callable(i)
func shutdown() =
    if !isActive then
        throw("DApp is already suspended. Cause: " + this.getString(keyCause).valueOrElse("the cause wasn't specified"))
    else if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStartStop].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else
        suspend("Paused by admin")

@Callable(i)
func activate() =
    if isActive then
        throw("DApp is already active")
    else if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStartStop].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else [
        BooleanEntry(keyActive, true),
        DeleteEntry(keyCause)
    ]

@Verifier(tx)
func verify() = {
    let adminPubKey1Signed = if sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey1) then 1 else 0
    let adminPubKey2Signed = if sigVerify(tx.bodyBytes, tx.proofs[1], adminPubKey2) then 1 else 0
    let adminPubKey3Signed = if sigVerify(tx.bodyBytes, tx.proofs[2], adminPubKey3) then 1 else 0
    adminPubKey1Signed + adminPubKey2Signed + adminPubKey3Signed >= 2
}
